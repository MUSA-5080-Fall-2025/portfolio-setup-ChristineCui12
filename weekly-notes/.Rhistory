aes(x = pct_college, y = median_incomeE) +
geom_point(alpha = 0.7) +
geom_smooth(method = "lm", se = FALSE) +
labs(title = "B) Education vs Income",
x = "% College Educated", y = "Median Income ($)") +
scale_y_continuous(labels = dollar) +
theme_minimal()
# Plot 3: Housing affordability by income category
p3 <- ggplot(full_data) +
aes(x = income_category, y = rent_to_income, fill = income_category) +
geom_boxplot() +
labs(title = "C) Housing Affordability by Income",
x = "Income Category", y = "Rent as % of Income") +
theme_minimal() +
theme(legend.position = "none")
# Plot 4: Data reliability by population
p4 <- ggplot(county_reliability) +
aes(x = total_popE, y = income_moe_pct) +
geom_point(alpha = 0.7) +
geom_hline(yintercept = 10, color = "red", linetype = "dashed") +
labs(title = "D) Data Reliability",
x = "Population", y = "MOE (%)") +
scale_x_continuous(labels = comma) +
theme_minimal()
# Combine all plots
combined_plot <- (p1 | p2) / (p3 | p4)
combined_plot + plot_annotation(
title = "Pennsylvania County Analysis: Income, Education, and Housing Patterns",
caption = "Source: American Community Survey 2018-2022"
)
# Complex multi-variable plot
ggplot(full_data) +
aes(x = pct_college, y = rent_to_income,
color = income_category, size = total_popE) +
geom_point(alpha = 0.7) +
labs(
title = "Education, Housing Affordability, and Income Patterns",
subtitle = "Larger points = larger population",
x = "Percent with Bachelor's Degree or Higher",
y = "Annual Rent as % of Median Income",
color = "Income Category",
size = "Population"
) +
theme_minimal() +
guides(size = guide_legend(override.aes = list(alpha = 1)))
#| eval: true
#| echo: true
# Load packages and data
library(tidyverse)
#| eval: true
#| echo: true
# Load packages and data
library(tidyverse)
library(sf)
library(here)
# Load Boston housing data
boston <- read_csv(here("data/boston.csv"))
# Quick look at the data
glimpse(boston)
# Simple model: Predict price from living area
baseline_model <- lm(SalePrice ~ LivingArea, data = boston)
summary(baseline_model)
#| eval: true
#| echo: false
# Look at key statistics
summary(baseline_model)
# Calculate R-squared
summary(baseline_model)$r.squared
# Visualize the relationship
ggplot(boston, aes(x = LivingArea, y = SalePrice)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red") +
labs(title = "Simple Linear Model: Living Area → Price",
x = "Living Area (sq ft)",
y = "Sale Price ($)") +
scale_y_continuous(labels = scales::dollar) +
theme_minimal()
#| eval: true
#| echo: true
# Add number of bathrooms
better_model <- lm(SalePrice ~ LivingArea + R_FULL_BTH, data = boston)
summary(better_model)
# Compare models
cat("Baseline R²:", summary(baseline_model)$r.squared, "\n")
cat("With bathrooms R²:", summary(better_model)$r.squared, "\n")
#| eval: true
#| echo: true
library(sf)
# Convert boston data to sf object
boston.sf <- boston %>%
st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
st_transform('ESRI:102286')  # MA State Plane (feet)
# Check it worked
head(boston.sf)
class(boston.sf)  # Should show "sf" and "data.frame"
#| eval: true
#| echo: true
# Load neighborhood boundaries
nhoods <- read_sf(here("data/BPDA_Neighborhood_Boundaries.geojson")) %>%
st_transform('ESRI:102286')  # Match CRS!
# Check the neighborhoods
head(nhoods)
nrow(nhoods)  # How many neighborhoods?
# Spatial join: Assign each house to its neighborhood
boston.sf <- boston.sf %>%
st_join(nhoods, join = st_intersects)
# Check results
boston.sf %>%
st_drop_geometry() %>%
count(name) %>%
arrange(desc(n))
#| eval: true
#| echo: false
# Map neighborhoods with median prices
price_by_nhood <- boston.sf %>%
st_drop_geometry() %>%
group_by(name) %>%
summarize(
median_price = median(SalePrice, na.rm = TRUE),
n_sales = n()
)
# Join back to spatial data
nhoods_prices <- nhoods %>%
left_join(price_by_nhood, by = "name")
# Create custom price classes
nhoods_prices <- nhoods_prices %>%
mutate(
price_class = cut(median_price,
breaks = c(0, 400000, 600000, 800000, 1000000, Inf),
labels = c("Under $400k", "$400k-$600k", "$600k-$800k",
"$800k-$1M", "Over $1M"),
include.lowest = TRUE)
)
# YlOrRd (Yellow-Orange-Red) - classic graduated
ggplot() +
geom_sf(data = nhoods_prices, aes(fill = price_class),
color = "white", size = 0.5) +
scale_fill_brewer(
name = "Median Price",
palette = "YlOrRd",  # Try also: "Reds", "OrRd", "YlGnBu", "PuRd"
na.value = "grey90",
direction = 1  # Use -1 to reverse (dark = low)
) +
labs(
title = "Median Home Prices by Boston Neighborhood",
) +
theme_void() +
theme(
legend.position = "right",
plot.title = element_text(face = "bold", size = 14),
legend.title = element_text(face = "bold")
)
#| eval: true
#| echo: true
# Which neighborhoods are most expensive?
price_by_nhood %>%
arrange(desc(median_price)) %>%
head(5)
# Which have most sales?
price_by_nhood %>%
arrange(desc(n_sales)) %>%
head(5)
#| eval: true
#| echo: false
# See what neighborhoods we have
boston.sf %>%
st_drop_geometry() %>%
count(name) %>%
arrange(desc(n)) %>%
head(10)
#| eval: true
#| echo: true
# Ensure name is a factor
boston.sf <- boston.sf %>%
mutate(name = as.factor(name))
# Check which is reference (first alphabetically)
levels(boston.sf$name)[1]
# Fit model with neighborhood fixed effects
model_neighborhoods <- lm(SalePrice ~ LivingArea + name,
data = boston.sf)
# Show just first 10 coefficients
summary(model_neighborhoods)$coef[1:10, ]
#| eval: true
#| echo: false
# CREATE OBJECTS NEEDED FOR LATER SLIDES
# Fit model with neighborhoods and bedrooms for predictions
model_with_neighborhoods <- lm(SalePrice ~ LivingArea + R_FULL_BTH + name,
data = boston.sf)
# Get reference neighborhood
ref_neighborhood <- levels(boston.sf$name)[1]
# Extract and format key coefficients
library(broom)
coef_table <- tidy(model_with_neighborhoods) %>%
filter(term %in% c("(Intercept)", "LivingArea", "R_BDRMS",
"nameBack Bay", "nameBeacon Hill", "nameCharlestown",
"nameDorchester", "nameRoxbury", "nameEast Boston")) %>%
mutate(
term = case_when(
term == "(Intercept)" ~ paste0("Intercept (", ref_neighborhood, ")"),
term == "LivingArea" ~ "Living Area (per sq ft)",
term == "R_BDRMS" ~ "Bedrooms",
str_detect(term, "name") ~ str_remove(term, "name"),
TRUE ~ term
),
estimate = scales::dollar(estimate, accuracy = 1),
p_value = case_when(
p.value < 0.001 ~ "< 0.001***",
p.value < 0.01 ~ paste0(round(p.value, 3), "**"),
p.value < 0.05 ~ paste0(round(p.value, 3), "*"),
TRUE ~ as.character(round(p.value, 3))
)
) %>%
select(Variable = term, Coefficient = estimate, `p-value` = p_value)
#| eval: true
#| echo: false
# Display the coefficient table
knitr::kable(coef_table, align = c('l', 'r', 'r'))
#| eval: true
#| echo: false
# Fit model with neighborhoods (reference = alphabetically first)
boston.sf <- boston.sf %>%
mutate(name = as.factor(name))
model_with_neighborhoods <- lm(SalePrice ~ LivingArea + R_FULL_BTH + name,
data = boston.sf)
# Get reference neighborhood
ref_neighborhood <- levels(boston.sf$name)[1]
# Extract and format key coefficients
library(broom)
coef_table <- tidy(model_with_neighborhoods) %>%
filter(term %in% c("(Intercept)", "LivingArea", "R_FULL_BTH",
"nameBack Bay", "nameBeacon Hill", "nameCharlestown",
"nameDorchester", "nameRoxbury", "nameEast Boston")) %>%
mutate(
term = case_when(
term == "(Intercept)" ~ paste0("Intercept (", ref_neighborhood, ")"),
term == "LivingArea" ~ "Living Area (per sq ft)",
term == "R_FULL_BTH" ~ "Full Baths",
str_detect(term, "name") ~ str_remove(term, "name"),
TRUE ~ term
),
estimate = scales::dollar(estimate, accuracy = 1),
p_value = case_when(
p.value < 0.001 ~ "< 0.001***",
p.value < 0.01 ~ paste0(round(p.value, 3), "**"),
p.value < 0.05 ~ paste0(round(p.value, 3), "*"),
TRUE ~ as.character(round(p.value, 3))
)
) %>%
select(Variable = term, Coefficient = estimate, `p-value` = p_value)
#knitr::kable(coef_table, align = c('l', 'r', 'r'))
#| eval: true
#| echo: false
# Example prediction for Back Bay
predict(model_with_neighborhoods,
newdata = data.frame(
LivingArea = 1500,
R_FULL_BTH = 2,
name = factor("Back Bay", levels = levels(boston.sf$name))
)) %>%
scales::dollar()
#| eval: true
#| echo: false
# Example prediction for Roxbury
predict(model_with_neighborhoods,
newdata = data.frame(
LivingArea = 1500,
R_FULL_BTH = 2,
name = factor("Roxbury", levels = levels(boston.sf$name))
)) %>%
scales::dollar()
#| eval: true
#| echo: false
price_backbay <- predict(model_with_neighborhoods,
newdata = data.frame(LivingArea = 1500, R_FULL_BTH  = 2,
name = factor("Back Bay", levels = levels(boston.sf$name))))
price_roxbury <- predict(model_with_neighborhoods,
newdata = data.frame(LivingArea = 1500, R_FULL_BTH  = 2,
name = factor("Roxbury", levels = levels(boston.sf$name))))
scales::dollar(price_backbay - price_roxbury)
#| eval: true
#| echo: true
# Define wealthy neighborhoods based on median prices
wealthy_hoods <- c("Back Bay", "Beacon Hill", "South End", "Bay Village")
# Create binary indicator
boston.sf <- boston.sf %>%
mutate(
wealthy_neighborhood = ifelse(name %in% wealthy_hoods, "Wealthy", "Not Wealthy"),
wealthy_neighborhood = as.factor(wealthy_neighborhood)
)
# Check the split
boston.sf %>%
st_drop_geometry() %>%
count(wealthy_neighborhood)
#| eval: true
#| echo: true
# Model assumes same slope everywhere
model_no_interact <- lm(SalePrice ~ LivingArea + wealthy_neighborhood,
data = boston.sf)
summary(model_no_interact)$coef
#| eval: true
#| echo: true
# Model allows different slopes
model_interact <- lm(SalePrice ~ LivingArea * wealthy_neighborhood,
data = boston.sf)
summary(model_interact)$coef
#| eval: true
#| echo: false
# Format results nicely
library(broom)
interact_results <- tidy(model_interact) %>%
mutate(
term_clean = case_when(
term == "(Intercept)" ~ "Intercept (Not Wealthy)",
term == "LivingArea" ~ "Living Area (Not Wealthy)",
term == "wealthy_neighborhoodWealthy" ~ "Wealthy Neighborhood Premium",
term == "LivingArea:wealthy_neighborhoodWealthy" ~ "Extra $/sq ft in Wealthy Areas",
TRUE ~ term
),
estimate_formatted = scales::dollar(estimate, accuracy = 1),
significance = case_when(
p.value < 0.001 ~ "***",
p.value < 0.01 ~ "**",
p.value < 0.05 ~ "*",
TRUE ~ ""
)
) %>%
select(Term = term_clean, Coefficient = estimate_formatted,
`t-value` = statistic, `p-value` = p.value, Sig = significance)
knitr::kable(interact_results, digits = 3, align = c('l', 'r', 'r', 'r', 'c'))
#| eval: true
#| echo: false
# Extract coefficients
coefs <- coef(model_interact)
base_intercept <- coefs[1]
base_slope <- coefs[2]
wealthy_intercept_add <- coefs[3]
wealthy_slope_add <- coefs[4]
# Calculate totals
wealthy_intercept <- base_intercept + wealthy_intercept_add
wealthy_slope <- base_slope + wealthy_slope_add
#| eval: true
#| echo: false
#| fig-width: 10
#| fig-height: 6
library(ggplot2)
ggplot(boston.sf, aes(x = LivingArea, y = SalePrice,
color = wealthy_neighborhood)) +
geom_point(alpha = 0.3, size = 2) +
geom_smooth(method = "lm", se = TRUE, linewidth = 1.5) +
scale_color_manual(
values = c("Not Wealthy" = "#3498db", "Wealthy" = "#e74c3c"),
name = "Neighborhood Type"
) +
scale_y_continuous(labels = scales::dollar_format(scale = 1/1000000, suffix = "M")) +
scale_x_continuous(labels = scales::comma) +
labs(
title = "Living Area Effect Varies by Neighborhood Wealth",
subtitle = "Different slopes = interaction effect (steeper line in wealthy areas)",
x = "Living Area (sq ft)",
y = "Sale Price",
caption = "Notice: The red line (wealthy) is steeper than the blue line (not wealthy)"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold", size = 14)
)
#| eval: true
#| echo: true
# Compare R-squared
cat("Model WITHOUT interaction R²:", round(summary(model_no_interact)$r.squared, 4), "\n")
cat("Model WITH interaction R²:", round(summary(model_interact)$r.squared, 4), "\n")
cat("Improvement:", round(summary(model_interact)$r.squared - summary(model_no_interact)$r.squared, 4), "\n")
#| eval: true
#| echo: false
# Calculate improvement
r2_improvement <- summary(model_interact)$r.squared - summary(model_no_interact)$r.squared
r2_pct_improvement <- (r2_improvement / summary(model_no_interact)$r.squared) * 100
#| eval: true
#| echo: true
# Calculate age from year built
boston.sf <- boston.sf %>%
mutate(Age = 2025 - YR_BUILT)%>% filter(Age <2000)
# Check the distribution of age
summary(boston.sf$Age)
# Visualize age distribution
ggplot(boston.sf, aes(x = Age)) +
geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7) +
labs(title = "Distribution of House Age in Boston",
x = "Age (years)",
y = "Count") +
theme_minimal()
#| eval: true
#| echo: true
# Simple linear relationship
model_age_linear <- lm(SalePrice ~ Age + LivingArea, data = boston.sf)
summary(model_age_linear)$coef
#| eval: true
#| echo: false
#| fig-width: 10
#| fig-height: 5
# Plot with linear fit
ggplot(boston.sf, aes(x = Age, y = SalePrice)) +
geom_point(alpha = 0.3) +
geom_smooth(method = "lm", color = "red", se = TRUE) +
geom_smooth(method = "loess", color = "blue", se = FALSE) +
scale_y_continuous(labels = scales::dollar_format(scale = 1/1000, suffix = "k")) +
labs(
title = "House Age vs. Price: Linear (red) vs. Flexible Curve (blue)",
x = "Age (years)",
y = "Sale Price",
caption = "Red = linear assumption, Blue = data-driven curve"
) +
theme_minimal()
#| eval: true
#| echo: true
# Quadratic model (Age²)
model_age_quad <- lm(SalePrice ~ Age + I(Age^2) + LivingArea, data = boston.sf)
summary(model_age_quad)$coef
#| eval: true
#| echo: false
# Extract coefficients
coefs_quad <- coef(model_age_quad)
beta_age <- coefs_quad["Age"]
beta_age2 <- coefs_quad["I(Age^2)"]
#| eval: true
#| echo: true
# R-squared comparison
r2_linear <- summary(model_age_linear)$r.squared
r2_quad <- summary(model_age_quad)$r.squared
cat("Linear model R²:", round(r2_linear, 4), "\n")
cat("Quadratic model R²:", round(r2_quad, 4), "\n")
cat("Improvement:", round(r2_quad - r2_linear, 4), "\n\n")
# F-test: Is the Age² term significant?
anova(model_age_linear, model_age_quad)
#| eval: true
#| echo: true
#| fig-width: 10
#| fig-height: 5
# Compare residual plots
par(mfrow = c(1, 2))
# Linear model residuals
plot(fitted(model_age_linear), residuals(model_age_linear),
main = "Linear Model Residuals",
xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, col = "red", lty = 2)
# Quadratic model residuals
plot(fitted(model_age_quad), residuals(model_age_quad),
main = "Quadratic Model Residuals",
xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, col = "red", lty = 2)
#| eval: true
#| echo: false
# load data
bostonCrimes <- read_csv(here("data/bostonCrimes.csv"))
glimpse(bostonCrimes)
boston.sf <- boston %>%
st_as_sf(coords = c("Longitude", "Latitude"), crs = "EPSG:4326") %>%
st_transform('ESRI:102286')
crimes.sf <- bostonCrimes %>%
filter(UCR_PART == "Part One", Lat > -1, !is.na(Lat), !is.na(Long)) %>%
st_as_sf(coords = c("Long", "Lat"), crs = "EPSG:4326") %>%
st_transform('ESRI:102286') %>%
distinct()
nhoods <- st_read(here("data/BPDA_Neighborhood_Boundaries.geojson")) %>%
st_transform('ESRI:102286')
# Quick check - these should all be similar numbers
st_bbox(boston.sf)
st_bbox(crimes.sf)
st_bbox(nhoods)
# Check for missing coordinates
cat("Records with missing coordinates:",
sum(is.na(bostonCrimes$Lat) | is.na(bostonCrimes$Long)), "\n")
# Filter to violent crimes (most relevant for housing prices)
violent_crimes <- bostonCrimes %>%
filter(
UCR_PART == "Part One",  # Serious crimes
!is.na(Lat), !is.na(Long)  # Must have coordinates
) %>%
select(OFFENSE_CODE_GROUP, OFFENSE_DESCRIPTION, SHOOTING,
Lat, Long, YEAR, OCCURRED_ON_DATE)
cat("Violent crime records:", nrow(violent_crimes), "\n")
# What types of crimes?
violent_crimes %>%
count(OFFENSE_CODE_GROUP, sort = TRUE) %>%
head(10)
# Transform to appropriate projected CRS
pa_tracts_proj <- st_transform(pa_tracts_demographics, crs = 4326)
# Load required packages
library(sf)
library(tidyverse)
library(tigris)
library(tidycensus)
library(scales)
library(patchwork)
library(here)
census_api_key("20068788c6e79d5716fbceb0dcd562ab23f74ca1")
# Load spatial data
# 1. Pennsylvania county boundaries
pa_counties <- st_read(here("labs/lab_2/data/Pennsylvania_County_Boundaries.shp"))
# Load required packages
library(sf)
library(tidyverse)
library(tigris)
library(tidycensus)
library(scales)
library(patchwork)
library(here)
census_api_key("20068788c6e79d5716fbceb0dcd562ab23f74ca1")
# Load spatial data
# 1. Pennsylvania county boundaries
pa_counties <- st_read(here("labs/lab_2/data/Pennsylvania_County_Boundaries.shp"))
