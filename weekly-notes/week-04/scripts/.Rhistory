library(sf)
library(tidyverse)
library(tigris)
library(tidycensus)
library(scales)
library(patchwork)
library(here)
# Set Census API key
census_api_key("42bf8a20a3df1def380f330cf7edad0dd5842ce6")
# Load the data (same as lecture)
pa_counties <- st_read(here("data/Pennsylvania_County_Boundaries.shp"))
districts <- st_read(here("data/districts.geojson"))
hospitals <- st_read(here("data/hospitals.geojson"))
census_tracts <- tracts(state = "PA", cb = TRUE)
metro_areas <- core_based_statistical_areas(cb = TRUE)
# Standardize CRS
hospitals <- st_transform(hospitals, st_crs(pa_counties))
census_tracts <- st_transform(census_tracts, st_crs(pa_counties))
metro_areas <- st_transform(metro_areas, st_crs(pa_counties))
districts <- st_transform(districts, st_crs(census_tracts))
# Step 1: Look at available county names
unique(pa_counties$COUNTY_NAM)
# Step 2: Pick one county (change this to your choice!)
my_county <- pa_counties %>%
filter(COUNTY_NAM == "CENTRE")  # Change "CENTRE" to your county
# Step 3: Find neighbors using st_touches
my_neighbors <- pa_counties %>%
st_filter(my_county, .predicate = st_touches)
# Step 4: How many neighbors does your county have?
cat("Number of neighboring counties:", nrow(my_neighbors), "\n")
print("Neighbor names:")
print(my_neighbors$COUNTY_NAM)
# Create the map
ggplot() +
geom_sf(data = pa_counties, fill = "lightgray", color = "white") +
geom_sf(data = my_neighbors, fill = "lightblue", alpha = 0.7) +
geom_sf(data = my_county, fill = "darkblue") +
labs(
title = paste("Neighbors of", my_county$COUNTY_NAM[1], "County"),
subtitle = paste(nrow(my_neighbors), "neighboring counties")
) +
theme_void()
# Use st_intersects
intersecting_counties <- pa_counties %>%
st_filter(my_county, .predicate = st_intersects)
cat("With st_touches:", nrow(my_neighbors), "counties\n")
cat("With st_intersects:", nrow(intersecting_counties), "counties\n")
cat("Difference:", nrow(intersecting_counties) - nrow(my_neighbors), "\n")
# Step 1: Filter hospitals in your county
# First do a spatial join to assign counties to hospitals
hospitals_with_county <- hospitals %>%
st_join(pa_counties %>% select(COUNTY_NAM))
# Filter for your county's hospitals
my_county_hospitals <- hospitals_with_county %>%
filter(COUNTY_NAM == "CENTRE")  # Change to match your county
cat("Number of hospitals in county:", nrow(my_county_hospitals), "\n")
# Step 2: Project to accurate CRS for buffering
my_county_hospitals_proj <- my_county_hospitals %>%
st_transform(3365)  # Pennsylvania State Plane South
# Step 3: Create 15-mile buffers (24140 meters = 15 miles)
hospital_service_areas <- my_county_hospitals_proj %>%
st_buffer(dist = 79200)  # 15 miles in feet for PA State Plane
# Step 4: Transform back for mapping
hospital_service_areas <- st_transform(hospital_service_areas, st_crs(pa_counties))
ggplot() +
geom_sf(data = my_county, fill = "white", color = "gray") +
geom_sf(data = hospital_service_areas, fill = "lightblue", alpha = 0.4) +
geom_sf(data = my_county_hospitals, color = "red", size = 2) +
labs(
title = paste("Hospital Service Areas in", my_county$COUNTY_NAM[1], "County"),
subtitle = "Red points = Hospitals, Blue areas = 15-mile service zones"
) +
theme_void()
# Union all service areas into one polygon
combined_service_area <- hospital_service_areas %>%
st_union()
# Calculate areas (need to be in projected CRS)
my_county_proj <- st_transform(my_county, 3365)
combined_service_proj <- st_transform(combined_service_area, 3365)
# Find intersection
coverage_area <- st_intersection(my_county_proj, combined_service_proj)
# Calculate percentages
county_area <- as.numeric(st_area(my_county_proj))
covered_area <- as.numeric(st_area(coverage_area))
coverage_pct <- (covered_area / county_area) * 100
cat("County area:", round(county_area / 1e6, 1), "sq km\n")
cat("Covered area:", round(covered_area / 1e6, 1), "sq km\n")
cat("Coverage:", round(coverage_pct, 1), "%\n")
# Spatial join: districts to counties
districts_by_county <- districts %>%
st_join(pa_counties %>% select(COUNTY_NAM)) %>%
st_drop_geometry() %>%
group_by(COUNTY_NAM) %>%
summarize(
n_districts = n_distinct(OBJECTID),
district_ids = paste(unique(MSLINK), collapse = ", ")
) %>%
arrange(desc(n_districts))
# Which counties have the most districts?
head(districts_by_county, 10)
# Get tract-level demographics
tract_demographics <- get_acs(
geography = "tract",
variables = c(
total_pop = "B01003_001",
median_income = "B19013_001",
white_pop = "B03002_003",
black_pop = "B03002_004",
hispanic_pop = "B03002_012"
),
state = "PA",
year = 2022,
output = "wide"
)
# Join to tract boundaries
tracts_with_data <- census_tracts %>%
left_join(tract_demographics, by = "GEOID")
# Spatial join to districts and aggregate
district_demographics <- tracts_with_data %>%
st_join(districts) %>%
st_drop_geometry() %>%
group_by(OBJECTID, MSLINK) %>%
summarize(
total_population = sum(total_popE, na.rm = TRUE),
median_income = weighted.mean(median_incomeE, total_popE, na.rm = TRUE),
pct_white = sum(white_popE, na.rm = TRUE) / sum(total_popE, na.rm = TRUE) * 100,
pct_black = sum(black_popE, na.rm = TRUE) / sum(total_popE, na.rm = TRUE) * 100,
pct_hispanic = sum(hispanic_popE, na.rm = TRUE) / sum(total_popE, na.rm = TRUE) * 100,
n_tracts = n()
) %>%
arrange(desc(total_population))
# Show results
head(district_demographics, 10)
# Join demographics back to district boundaries
districts_with_demographics <- districts %>%
left_join(district_demographics, by = "OBJECTID")
# Create the map
ggplot(districts_with_demographics) +
geom_sf(aes(fill = median_income), color = "white", size = 0.5) +
scale_fill_viridis_c(
name = "Median\nIncome",
labels = dollar,
option = "plasma"
) +
labs(
title = "Median Household Income by Congressional District",
subtitle = "Pennsylvania",
caption = "Source: ACS 2018-2022"
) +
theme_void()
# Calculate diversity index (simple version: higher = more diverse)
# A perfectly even distribution would be ~33% each for 3 groups
district_demographics <- district_demographics %>%
mutate(
diversity_score = 100 - abs(pct_white - 33.3) - abs(pct_black - 33.3) - abs(pct_hispanic - 33.3)
) %>%
arrange(desc(diversity_score))
# Most diverse districts
head(district_demographics %>% select(MSLINK, pct_white, pct_black, pct_hispanic, diversity_score), 5)
# Least diverse districts
tail(district_demographics %>% select(MSLINK, pct_white, pct_black, pct_hispanic, diversity_score), 5)
# Calculate areas in different CRS
area_comparison <- pa_counties %>%
# Geographic (WGS84) - WRONG for areas!
st_transform(4326) %>%
mutate(area_geographic = as.numeric(st_area(.))) %>%
# PA State Plane South - Good for PA
st_transform(3365) %>%
mutate(area_state_plane = as.numeric(st_area(.))) %>%
# Albers Equal Area - Good for areas
st_transform(5070) %>%
mutate(area_albers = as.numeric(st_area(.))) %>%
st_drop_geometry() %>%
select(COUNTY_NAM, starts_with("area_")) %>%
mutate(
# Calculate errors compared to Albers (most accurate for area)
error_geographic_pct = abs(area_geographic - area_albers) / area_albers * 100,
error_state_plane_pct = abs(area_state_plane - area_albers) / area_state_plane * 100
)
# Show counties with biggest errors
area_comparison %>%
arrange(desc(error_geographic_pct)) %>%
select(COUNTY_NAM, error_geographic_pct, error_state_plane_pct) %>%
head(10)
# Join error data back to counties
counties_with_errors <- pa_counties %>%
left_join(
area_comparison %>% select(COUNTY_NAM, error_geographic_pct),
by = "COUNTY_NAM"
)
# Map the error
ggplot(counties_with_errors) +
geom_sf(aes(fill = error_geographic_pct), color = "white") +
scale_fill_viridis_c(
name = "Area\nError %",
option = "magma"
) +
labs(
title = "Area Calculation Errors by County",
subtitle = "Using geographic coordinates (WGS84) instead of projected CRS"
) +
theme_void()
# Your code here!
# 步骤 1: 获取人口普查区的人口、老年人口和贫困数据
# Variables:
# B01003_001E: Total Population
# B01001_025E: Population 65 years and over
# B17020_001E: Total for Poverty Status
# B17020_002E: Income below poverty level
tract_demographics_vulnerability <- get_acs(
geography = "tract",
variables = c(
total_pop = "B01003_001",
elderly_pop = "B01001_025",
poverty_total = "B17020_001",
poverty_below = "B17020_002"
),
state = "PA",
year = 2022,
output = "wide"
)
# ----------------------------------------------------------------------
# 步骤 2: 识别脆弱的普查区 (Vulnerable Tracts)
# ----------------------------------------------------------------------
# 阈值定义
ELDERLY_PCT_THRESHOLD <- 0.20 # 20%
POVERTY_PCT_THRESHOLD <- 0.15 # 15%
DISTANCE_THRESHOLD_MILES <- 15
DISTANCE_THRESHOLD_FEET <- 15 * 5280 # 15 miles in feet for EPSG:3365
# 联合几何数据和人口数据，并识别脆弱性
vulnerable_tracts_sf <- census_tracts %>%
# 移除水域/非居住区域
filter(ALAND > 0) %>%
left_join(tract_demographics_vulnerability, by = "GEOID") %>%
mutate(
# 计算老年人口比例和贫困率
elderly_pct = elderly_popE / total_popE,
poverty_pct = poverty_belowE / poverty_totalE,
# 识别脆弱普查区 (高老年比例 AND 高贫困率)
is_vulnerable = (elderly_pct >= ELDERLY_PCT_THRESHOLD & poverty_pct >= POVERTY_PCT_THRESHOLD)
) %>%
# 只保留脆弱的普查区
filter(is_vulnerable == TRUE) %>%
# 选择必要的列并计算质心（用于距离计算）
select(GEOID, COUNTYFP, total_popE, is_vulnerable) %>%
st_centroid() # 使用普查区中心点进行距离计算
# ----------------------------------------------------------------------
# 步骤 3 & 4: 计算距离并识别服务不足地区 (Underserved)
# ----------------------------------------------------------------------
# 投影到 PA State Plane South (EPSG:3365) 以进行准确的距离计算
vulnerable_tracts_proj <- st_transform(vulnerable_tracts_sf, 3365)
hospitals_proj <- st_transform(hospitals, 3365)
# 1. 找到每个脆弱普查区到最近医院的索引
nearest_hospital_index <- st_nearest_feature(vulnerable_tracts_proj, hospitals_proj)
# 2. 计算到最近医院的距离（英尺）
vulnerable_tracts_proj <- vulnerable_tracts_proj %>%
mutate(
dist_to_hospital_ft = st_distance(
.,
hospitals_proj[nearest_hospital_index, ],
by_element = TRUE # 确保按行计算
),
# 识别服务不足 (距离 > 15 英里)
is_underserved = (dist_to_hospital_ft > set_units(DISTANCE_THRESHOLD_FEET, "ft"))
)
# Your code here!
