)
pa_demographics <- get_acs(
geography = "tract",
state = "PA",
variables = acs_vars,
output = "wide",
year = 2022,
geometry = FALSE
) %>%
# Calculate the combined 65+ population and rename variables
mutate(
pop_65_over = male_65_66E + male_67_69E + male_70_74E + male_75_79E + male_80_84E + male_85_upE +
female_65_66E + female_67_69E + female_70_74E + female_75_79E + female_80_84E + female_85_upE
) %>%
# Select and rename final columns for clarity and consistency
select(
GEOID,
total_pop = total_popE,
med_hh_income = med_hh_incomeE,
pop_65_over
)
# Join to tract boundaries
pa_tracts_demographics <- census_tracts %>%
left_join(pa_demographics, by = "GEOID")
#tracts have missing income data
missing_income_count <- pa_tracts_demographics %>%
summarise(missing_count = sum(is.na(med_hh_income))) %>%
pull(missing_count)
#median income across all PA census tracts
median_tract_income <- pa_tracts_demographics %>%
filter(!is.na(med_hh_income)) %>%
summarise(median_income = median(med_hh_income)) %>%
pull(median_income)
# Filter for vulnerable tracts based on your criteria
pa_tracts_demographics <- pa_tracts_demographics %>%
mutate(pct_65_over = (pop_65_over / total_pop) * 100)
income_threshold <- quantile(pa_tracts_demographics$med_hh_income, 0.25, na.rm = TRUE)
elderly_threshold <- quantile(pa_tracts_demographics$pct_65_over, 0.75, na.rm = TRUE)
pa_tracts_demographics <- pa_tracts_demographics %>%
mutate(
income_low = med_hh_income < income_threshold,
elderly_high = pct_65_over > elderly_threshold,
vulnerable = if_else(income_low & elderly_high, TRUE, FALSE)
)
# Summary: how many tracts are vulnerable?
vulnerable_summary <- pa_tracts_demographics %>%
summarise(
total_tracts = n(),
vulnerable_tracts = sum(vulnerable, na.rm = TRUE),
pct_vulnerable = round((vulnerable_tracts / total_tracts) * 100, 1)
)
vulnerable_summary
# Transform to appropriate projected CRS
pa_tracts_proj <- st_transform(pa_tracts_demographics, crs = 4326)
hospitals_proj <- st_transform(hospitals, crs = 4326)
# Calculate distance from each tract centroid to nearest hospital 中心点 (Centroid)
tract_centroids <- st_centroid(pa_tracts_proj)
nearest_dist_m <- st_distance(tract_centroids, hospitals_proj) %>%
apply(1, min)  # minimum distance for each tract
pa_tracts_proj <- pa_tracts_proj %>%
mutate(
dist_to_hospital_m = nearest_dist_m,
dist_to_hospital_mi = dist_to_hospital_m / 1609.34
)
vulnerable_distance_summary <- pa_tracts_proj %>%
filter(vulnerable == TRUE) %>%
summarise(
avg_distance_mi = mean(dist_to_hospital_mi, na.rm = TRUE),
max_distance_mi = max(dist_to_hospital_mi, na.rm = TRUE),
over_15_miles = sum(dist_to_hospital_mi > 15, na.rm = TRUE)
)
vulnerable_distance_summary
# Create underserved variable
pa_tracts_proj <- pa_tracts_proj %>%
mutate(
underserved = if_else(vulnerable == TRUE & dist_to_hospital_mi > 15, TRUE, FALSE)
)
# Summarize underserved tracts
underserved_summary <- pa_tracts_proj %>%
summarise(
total_tracts = n(),
vulnerable_tracts = sum(vulnerable, na.rm = TRUE),
underserved_tracts = sum(underserved, na.rm = TRUE),
pct_underserved = round((underserved_tracts / vulnerable_tracts) * 100, 1)
)
underserved_summary
# Spatial join tracts to counties
pa_counties_proj <- st_transform(pa_counties, st_crs(pa_tracts_proj))
tracts_county_join <- st_join(pa_tracts_proj, pa_counties_proj, join = st_intersects, left = TRUE)
# Aggregate statistics by county
county_summary <- tracts_county_join %>%
st_drop_geometry() %>%
group_by(COUNTY_NAM) %>%
summarise(
n_tracts = n(),
vulnerable_tracts = sum(vulnerable, na.rm = TRUE),
underserved_tracts = sum(underserved, na.rm = TRUE),
pct_underserved_vulnerable = round((underserved_tracts / vulnerable_tracts) * 100, 1),
avg_distance_vulnerable = mean(dist_to_hospital_mi[vulnerable == TRUE], na.rm = TRUE),
total_vulnerable_pop = sum(total_pop[vulnerable == TRUE], na.rm = TRUE),
underserved_vulnerable_pop = sum(total_pop[vulnerable == TRUE & underserved == TRUE], na.rm = TRUE)
) %>%
arrange(desc(pct_underserved_vulnerable))
head(county_summary, 10)
# Plot map of percent underserved by Pennsylvania counties.
county_map <- pa_counties_proj %>%
left_join(county_summary %>% select(COUNTY_NAM, pct_underserved_vulnerable),
by = c("COUNTY_NAM" = "COUNTY_NAM"))
ggplot() +
# Counties filled by % underserved vulnerable tracts
geom_sf(data = county_map, aes(fill = pct_underserved_vulnerable),
color = "white", size = 0.3) +
# Color scale for underserved percentage
scale_fill_viridis_c(
name = "Percent Underserved",
option = "viridis",
direction = -1,
labels = function(x) paste0(x, "%")
) +
# Map titles and caption
labs(
title = "PERCENT UNDERSERVED BY PENNSYLVANIA COUNTIES",
subtitle = "Pennsylvania, US",
caption = "Data sources: ACS (2022)"
) +
# Clean minimal theme with custom styling
theme_void() +
theme(
panel.background = element_rect(fill = "white", color = NA),
plot.background = element_rect(fill = "white", color = NA),
plot.title = element_text(
size = 14,
face = "bold",
hjust = 0.5,
margin = margin(b = 5, unit = "pt")
),
plot.subtitle = element_text(
size = 10,
hjust = 0.5,
margin = margin(b = 15, t = 5, unit = "pt")
),
legend.title = element_text(
size = 11,
face = "bold"
),
legend.text = element_text(
size = 10,
),
plot.caption = element_text(
size = 9,
color = "gray40",
face = "italic",
margin = margin(t = 10, unit = "pt")
),
legend.position = "right",
legend.box.margin = margin(l = 0, unit = "pt")
)
top5_pct <- county_summary %>%
arrange(desc(pct_underserved_vulnerable)) %>%
slice_head(n = 5)
top5_pct
top1_pop <- county_summary %>%
arrange(desc(underserved_vulnerable_pop)) %>%
slice_head(n = 1)
top1_pop
# Create and format priority counties table
library(knitr)
library(scales)
# 7.1 Select and format key variables for display
priority_counties <- county_summary %>%
arrange(desc(pct_underserved_vulnerable)) %>%
slice_head(n = 10) %>%
select(
County = COUNTY_NAM,
`Vulnerable Tracts` = vulnerable_tracts,
`Underserved Tracts` = underserved_tracts,
`% Underserved` = pct_underserved_vulnerable,
`Avg Distance (mi)` = avg_distance_vulnerable,
`Total Vulnerable Population` = total_vulnerable_pop
) %>%
mutate(
`Total Vulnerable Population` = comma(`Total Vulnerable Population`),  # add commas
`% Underserved` = percent(`% Underserved` / 100, accuracy = 0.1),
`Avg Distance (mi)` = round(`Avg Distance (mi)`, 1)
)
# 2. Create professional summary table
kable(
priority_counties,
caption = "Table 1. Top 10 Pennsylvania Counties with the Highest Percentage of Underserved Vulnerable Tracts",
align = "lccccc",
digits = 1,
format = "html"
)
# Create county-level access map
library(ggplot2)
library(viridis)
county_map_data <- pa_counties_proj %>%
left_join(county_summary, by = c("COUNTY_NAM" = "COUNTY_NAM"))
ggplot() +
# Counties filled by % underserved vulnerable tracts
geom_sf(data = county_map_data, aes(fill = pct_underserved_vulnerable),
color = "white", size = 0.3) +
# Hospital locations as points
geom_sf(data = hospitals_proj, aes(color = "Hospitals"),
size = 1, alpha = 0.7, show.legend = "point") +
# Color scale for access challenge
scale_fill_viridis(
name = "Percent Underserved",
option = "C",
direction = -1,
labels = function(x) paste0(x, "%")
) +
# Hospital point color scale
scale_color_manual(
name = "",
values = c("Hospitals" = "red2")
) +
# Map titles and caption
labs(
title = "URDERSERVED COUNTIES AND HOSPITAL LOCATION",
subtitle = "Pennsylvania, US",
caption = "Data sources: ACS (2022), Pennsylvania Hospital Data"
) +
# Clean minimal theme with custom styling
theme_void() +
theme(
panel.background = element_rect(fill = "white", color = NA),
plot.background = element_rect(fill = "white", color = NA),
plot.title = element_text(
size = 14,
face = "bold",
hjust = 0.5,
margin = margin(b = 5, unit = "pt")
),
plot.subtitle = element_text(
size = 10,
hjust = 0.5,
margin = margin(b = 15, t = 5, unit = "pt")
),
legend.title = element_text(
size = 11,
face = "bold"
),
legend.text = element_text(
size = 10,
),
plot.caption = element_text(
size = 9,
color = "gray40",
face = "italic",
margin = margin(t = 10, unit = "pt")
),
legend.position = "right",
legend.box.margin = margin(l = 10, unit = "pt")
)
# Create detailed tract-level map
ggplot() +
geom_sf(data = pa_tracts_proj, fill = "grey90", color = NA) +
geom_sf(data = filter(pa_tracts_proj, vulnerable == TRUE & underserved == FALSE),
fill = "#FED976", color = NA) +
geom_sf(data = filter(pa_tracts_proj, underserved == TRUE & vulnerable == TRUE),
fill = "#E31A1C", color = "white", size = 0.05) +
geom_sf(data = pa_counties_proj, fill = NA, color = "white", size = 0.3) +
geom_sf(data = hospitals_proj, color = "blue", size = 0.8, alpha = 0.7) +
labs(
title = "Underserved Vulnerable Tracts in Pennsylvania",
subtitle = "Red areas represent underserved tracts, Yellow areas represent vulnerable tracts",
caption = "Data sources: ACS (2022)"
) +
# style
theme_void() +
theme(
plot.title = element_text(size = 18, face = "bold"),
plot.subtitle = element_text(size = 12),
plot.caption = element_text(size = 9, color = "grey50",face = "italic",)
)
# Create distribution visualization
library(ggplot2)
library(scales)
vulnerable_tract <- pa_tracts_demographics %>%
filter(vulnerable == TRUE)
ggplot(
data = pa_tracts_proj %>% filter(vulnerable == TRUE),
aes(x = dist_to_hospital_mi)
) +
geom_histogram(
aes(y = after_stat(count), weight = total_pop),
bins = 30,
fill = "#74add1",
color = "white",
alpha = 0.8
) +
geom_vline(xintercept = 15, linetype = "dashed", color = "red", size = 1) +
annotate("text", x = 15.5, y = 10000, label = "15-mile threshold", hjust = 0, color = "red", size = 3) +
labs(
title = "Distribution of Hospital Distance for Vulnerable Population",
subtitle = "Histogram weighted by the total population of vulnerable census tracts",
x = "Distance to Nearest Hospital (miles)",
y = "Total Vulnerable Population Count",
caption = "Source: ACS (2022), Pennsylvania Hospital Data"
) +
scale_y_continuous(labels = scales::comma) + # 格式化 Y 轴数字
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold"),
plot.subtitle = element_text(size = 11),
plot.caption = element_text(size = 9, color = "gray50")
)
# Load your additional dataset
parks <- st_read(here("labs/lab_2/data/PPR_Properties.geojson"))
trees <- st_read(here("labs/lab_2/data/ppr_tree_canopy_points_2015.geojson"))
# Transform to match our previous analysis (EPSG:4326)
parks_proj <- st_transform(parks, crs = 4326)
trees_proj <- st_transform(trees, crs = 4326)
# Basic summary statistics
cat("\n--- Summary Statistics ---\n")
cat("Total parks in Philadelphia:", nrow(parks), "\n")
cat("Total street trees in Philadelphia:", nrow(trees), "\n")
# 2. Get Philadelphia-specific census tracts and demographics for the analysis
philly_tracts <- get_acs(
geography = "tract",
variables = c(
total_pop = "B01003_001",
median_income = "B19013_001",
white = "B02001_002",
black = "B02001_003",
asian = "B02001_005",
hispanic = "B03003_003"
),
state = "PA",
county = "Philadelphia",
geometry = TRUE,
year = 2022,
survey = "acs5"
)
philly_tracts <- philly_tracts %>%
select(GEOID, NAME, variable, estimate, geometry) %>%
st_as_sf() %>%
st_transform(3857) %>%
pivot_wider(names_from = variable, values_from = estimate) %>%
mutate(
pct_white = white / total_pop * 100,
pct_black = black / total_pop * 100,
pct_asian = asian / total_pop * 100,
pct_hispanic = hispanic / total_pop * 100,
pct_nonwhite = 100 - pct_white
)
philly_tracts_proj <- st_transform(philly_tracts, crs = 4326)
cat("\n--- Summary Statistics ---\n")
cat("Total tracts in Philadelphia:", nrow(philly_tracts), "\n")
# Your spatial analysis
# --- 1. Calculate park and tree accessibility metrics ---
# Compute centroids for each census tract
tract_centroids <- st_centroid(philly_tracts_proj)
# Calculate distance (in meters) from each tract centroid to the nearest park
dist_to_park <- st_distance(tract_centroids, parks_proj) %>%
apply(1, min)  # min distance for each tract
# Calculate distance to the nearest tree canopy point (proxy for green coverage)
dist_to_tree <- st_distance(tract_centroids, trees_proj) %>%
apply(1, min)
# Add distance variables back to tracts
philly_tracts_proj <- philly_tracts_proj %>%
mutate(
dist_to_park_m = as.numeric(dist_to_park),
dist_to_tree_m = as.numeric(dist_to_tree),
dist_to_park_km = dist_to_park_m / 1000,
dist_to_tree_km = dist_to_tree_m / 1000
)
# --- 2. Explore correlations between green access and demographics ---
# Examine whether lower-income or higher-nonwhite areas are farther from green space
cor_test_income <- cor.test(philly_tracts_proj$median_income, philly_tracts_proj$dist_to_park_km, use = "complete.obs")
cor_test_nonwhite <- cor.test(philly_tracts_proj$pct_nonwhite, philly_tracts_proj$dist_to_park_km, use = "complete.obs")
cat("\n--- Correlation Results ---\n")
cat("Income vs. Distance to Park (r):", round(cor_test_income$estimate, 3), "\n")
cat("Pct Nonwhite vs. Distance to Park (r):", round(cor_test_nonwhite$estimate, 3), "\n")
# --- 3. Classify tracts by socioeconomic characteristics ---
income_median <- median(philly_tracts_proj$median_income, na.rm = TRUE)
nonwhite_median <- median(philly_tracts_proj$pct_nonwhite, na.rm = TRUE)
philly_tracts_proj <- philly_tracts_proj %>%
mutate(
income_group = if_else(median_income < income_median, "Low Income", "High Income"),
race_group = if_else(pct_nonwhite > nonwhite_median, "High Nonwhite", "Low Nonwhite")
)
# --- 4. Visualize distance to parks by income and race group ---
# Boxplot comparison
ggplot(philly_tracts_proj %>% st_drop_geometry(),
aes(x = income_group, y = dist_to_park_km, fill = race_group)) +
geom_boxplot(alpha = 0.8, outlier.color = "gray40") +
scale_fill_viridis_d(name = "Race Group") +
labs(
title = "Park Accessibility by Income and Racial Composition",
subtitle = "Philadelphia Census Tracts (2022 ACS + OpenDataPhilly)",
x = "Income Group",
y = "Distance to Nearest Park (km)"
) +
theme_minimal(base_size = 13)
# --- 5. Map visualization: spatial distribution of green access ---
green_access_map <- ggplot(philly_tracts_proj) +
# Census tracts are color-filled by distance to parks
geom_sf(
aes(fill = dist_to_park_km),
color = "white",
linewidth = 0.1
) +
# parks boundary
geom_sf(
data = parks_proj,
fill = "#c7e9c0",
color = "#a1d99b",
alpha = 0.7,
linewidth = 0.3
) +
# trees location
geom_sf(
data = trees_proj %>% sample_n(min(5000, nrow(trees_proj))),
color = "#006d2c",
size = 0.1,
alpha = 0.3
) +
# Use a sequential color scale
scale_fill_gradientn(
name = "Distance to Park (km)",
colors = c("#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000"),
limits = c(0, max(philly_tracts_proj$dist_to_park_km, na.rm = TRUE)),
na.value = "grey80"
) +
labs(
title = "GREEN SPACE ACCESSIBILITY IN PHILADELPHIA",
subtitle = "Distance to Nearest Park by Census Tract",
caption = "Data sources: ACS (2022)"
) +
theme_void()
# Apply the theme style
green_access_map + theme(
panel.background = element_rect(fill = "white", color = NA),
plot.background = element_rect(fill = "white", color = NA),
legend.box.margin = margin(l = 10, unit = "pt"),
legend.title = element_text(face = "bold", size = 10),
legend.text = element_text(size = 8),
plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 15, t = 5, unit = "pt")),
plot.caption = element_text(margin = margin(t = 15, unit = "pt"), face = "italic", size = 9)
)
# --- 6. Scatter Plot: Income vs. Park Accessibility ---
scatter_plot <- ggplot(philly_tracts_proj %>% st_drop_geometry(),
aes(x = median_income, y = dist_to_park_km)) +
geom_point(aes(color = pct_nonwhite, size = total_pop), alpha = 0.7) +
geom_smooth(method = "lm", se = TRUE, color = "#e31a1c", linetype = "dashed") +
scale_color_gradientn(
name = "Nonwhite %",
colors = c("#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000")
) +
scale_size_continuous(name = "Population", range = c(1, 6)) +
labs(
title = "INCOME VS. PARK ACCESSIBILITY",
subtitle = "Each point represents a census tract (size = population, color = % nonwhite)",
x = "Median Household Income ($)",
y = "Distance to Nearest Park (km)",
caption = paste("Correlation r =", round(cor_test_income$estimate, 3))
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "right"
)
print(scatter_plot)
# --- 7. Scatter Plot: Racial Composition vs. Park Accessibility ---
scatter_plot_race <- ggplot(philly_tracts_proj %>% st_drop_geometry(),
aes(x = pct_nonwhite, y = dist_to_park_km)) +
geom_point(aes(color = median_income, size = total_pop), alpha = 0.7) +
geom_smooth(method = "lm", se = TRUE, color = "#e31a1c", linetype = "dashed") +
scale_color_gradientn(
name = "Median Income ($)",
colors = c("#f7fbff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"),
labels = scales::dollar
) +
scale_size_continuous(name = "Population", range = c(1, 6)) +
scale_x_continuous(labels = scales::percent_format(scale = 1)) +
labs(
title = "RACIAL COMPOSITION VS. PARK ACCESSIBILITY",
subtitle = "Each point represents a census tract (size = population, color = median income)",
x = "Percentage Nonwhite Population",
y = "Distance to Nearest Park (km)",
caption = paste("Correlation r =", round(cor_test_nonwhite$estimate, 3))
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "right"
)
print(scatter_plot_race)
# 2. Get Philadelphia-specific census tracts and demographics for the analysis
options(tigris_progress_bar = FALSE)
philly_tracts <- get_acs(
geography = "tract",
variables = c(
total_pop = "B01003_001",
median_income = "B19013_001",
white = "B02001_002",
black = "B02001_003",
asian = "B02001_005",
hispanic = "B03003_003"
),
state = "PA",
county = "Philadelphia",
geometry = TRUE,
year = 2022,
survey = "acs5",
cache = TRUE
)
